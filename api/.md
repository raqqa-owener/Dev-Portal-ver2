Dev Portal & Translation → Chroma Pipeline API

FastAPI + PostgreSQL で動く、業務モデルのメタデータ管理と翻訳パイプライン（Extract → Translate → optional Writeback → Package → Chroma upsert）を提供します。
This README is in English for public GitHub; a short Japanese note is included where helpful.

Features

CRUD for portal_* tables (model / field / view_common / view / tab / smart_button / menu)

Import from IR sources: ir_model_src, ir_field_src, ir_view_src

View bootstrap: expand view_types[] in portal_view_common into portal_view skeletons

Translation pipeline endpoints (extract, run, writeback)

Packaging to portal_chroma_doc and Chroma upsert/search

Idempotent POSTs with Idempotency-Key (optional)

Problem+JSON error responses and keyset pagination (cursor)

Architecture (high level)
IR tables (source)
 ├─ public.ir_model_src
 ├─ public.ir_field_src
 └─ public.ir_view_src
        │
        ▼  (import)
portal_* tables (CRUD domain)
 ├─ portal_model
 ├─ portal_fields
 ├─ portal_view_common ──► (bootstrap) ──► portal_view
 ├─ portal_tab
 ├─ portal_smart_button
 └─ portal_menu
        │
        ▼  (extract / translate / writeback / package)
portal_chroma_doc ──► (upsert) ──► Chroma ──► (search)

Tech Stack

Python 3.11

FastAPI / Uvicorn

SQLAlchemy 2.x

PostgreSQL 14+

(Optional) Chroma for vector search

Getting Started
1) Prerequisites

Python 3.11

PostgreSQL (accessible DATABASE_URL)

(Optional) Chroma server

2) Environment

Create .env (or export env vars):

DATABASE_URL=postgresql+psycopg2://user:pass@localhost:5432/devportal
APP_ENV=dev
LOG_LEVEL=INFO
CORS_ORIGINS=*
# Optional for Chroma integration
CHROMA_URL=http://localhost:8000

3) Install & Run
pip install -r requirements.txt
uvicorn app.main:app --reload --port 8080


OpenAPI/Swagger: http://localhost:8080/docs
Raw schema: http://localhost:8080/openapi.json

Database & IR Sources

This app expects IR source tables:

public.ir_model_src(model, model_table, label_en_us, …)

public.ir_field_src(model_table, field_name, ttype, label_ja_jp, label_en_us, notes, …)

public.ir_view_src(action_xmlid, action_id, action_name, model_tech, model_table, view_types, primary_view_type, help_*, ai_purpose, …)

Populate these from your upstream (e.g., ERP). The app imports from them into portal_*.

Typical Workflow

Import models (with optional scaffold if missing in IR):

curl -sS -X POST 'http://localhost:8080/portal/model/import' \
  -H 'Content-Type: application/json' \
  -d '{"models":["stock.picking"],"scaffold":true}'


Import fields for a model (selective list):

curl -sS -X POST 'http://localhost:8080/portal/field/import' \
  -H 'Content-Type: application/json' \
  -d '{"model":"stock.picking","fields":["origin","partner_id","scheduled_date"]}'


Import action-centric view_common from ir_view_src:

curl -sS -X POST 'http://localhost:8080/portal/view_common/import' \
  -H 'Content-Type: application/json' \
  -d '{"action_xmlids":["stock.action_picking_tree_all"]}'


Bootstrap view skeletons from portal_view_common.view_types[]:

curl -sS -X POST 'http://localhost:8080/portal/view_common/bootstrap_view' \
  -H 'Content-Type: application/json' \
  -d '{"action_xmlids":["stock.action_picking_tree_all"],"set_primary_from_common":true}'


Extract texts to translation queue:

# view_common (ai_purpose/help)
curl -sS -X POST 'http://localhost:8080/portal/view_common/extract' \
  -H 'Content-Type: application/json' \
  -d '{"action_xmlids":["stock.action_picking_tree_all"],"targets":["ai_purpose","help"]}'
# field (label/notes)
curl -sS -X POST 'http://localhost:8080/portal/field/extract' \
  -H 'Content-Type: application/json' \
  -d '{"models":["stock.picking"],"fields":["origin"]}'


Run translate (Cron internal):

curl -sS -X POST 'http://localhost:8080/translate/run' \
  -H 'Content-Type: application/json' \
  -d '{"limit":200,"source_lang":"ja_JP","target_lang":"en_US","entities":["field","view_common"]}'


Writeback translated results (dev-only, optional):

curl -sS -X POST 'http://localhost:8080/writeback/view_common' \
  -H 'Content-Type: application/json' \
  -d '{"action_xmlids":["stock.action_picking_tree_all"],"targets":["ai_purpose","help"]}'


Package to portal_chroma_doc:

curl -sS -X POST 'http://localhost:8080/chroma/package' \
  -H 'Content-Type: application/json' \
  -d '{"entities":["field","view_common"],"lang":"ja"}'


Chroma upsert (Cron internal):

curl -sS -X POST 'http://localhost:8080/chroma/upsert' \
  -H 'Content-Type: application/json' \
  -d '{"limit":1000,"dry_run":false}'


Search (prod-exposed endpoint):

curl -sS -X POST 'http://localhost:8080/chroma/search' \
  -H 'Content-Type: application/json' \
  -d '{"collection":"portal_view_common_ja","query":"入出庫一覧の説明","top_k":5}'

API Notes

Idempotency: Supply Idempotency-Key header for POST/PUT to avoid duplicate side effects.

Correlation: Optional X-Request-ID header for tracing.

Errors: Problem+JSON (application/problem+json).

Pagination: Keyset via cursor (pass back next_cursor).

See /openapi.json or Swagger /docs for full schema.
The English OpenAPI descriptions match the codebase conventions.

Project Layout (excerpt)
app/
 ├─ routers/
 │   ├─ portal_model.py
 │   ├─ portal_field.py
 │   ├─ portal_view_common.py
 │   └─ ...
 ├─ repos/
 │   ├─ portal_field_repo.py       # Session/Connection unified
 │   ├─ portal_view_common_repo.py # Session/Connection unified
 │   └─ pg_helpers.py              # UPSERT helpers
 ├─ services/
 │   ├─ portal_import.py           # model/field/view_common imports
 │   ├─ bootstrap_view.py          # view bootstrap
 │   └─ extract.py                 # extract to translate
 └─ utils/ ...

Troubleshooting

TypeError: Boolean value of this clause is not defined (SQLAlchemy)
Caused by evaluating a ClauseElement in a boolean context (if not self.sess or not getattr(self, "t", None):).
✅ Fix: Always check is None / hasattr(...) instead of truthiness, and avoid leaking ClauseElement into dict values (stringify if needed). Repos here already guard against this.

Pydantic v2 class-not-fully-defined / TypeAdapter[...]
Happens with forward refs + Annotated in OpenAPI generation.
✅ Fix: make sure request-body models are declared (not via Query) and call model_rebuild() if forward refs are used. Current routers keep body models as Body(...).

AttributeError: c in upsert helper
Caused by accessing ins.excluded.c on a non-table insert.
✅ Fix: use sa.dialects.postgresql.insert(table) and reference insert_stmt.excluded[column]. The included pg_helpers.py does this correctly.

Contributing

Fork & PR

Style: black + isort

Small, focused commits with tests where possible

Please add/adjust OpenAPI descriptions for new endpoints

License

Choose a license (e.g., MIT/Apache-2.0). Add a LICENSE file in the repo root.

Roadmap (suggested)

Export CLI for common import/bootstrap flows

Background jobs for translate/package/upsert

More granular diff-aware upserts (upsert_if_changed)

i18n coverage reports and dashboards